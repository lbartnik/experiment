---
title: "Supporting Data Processing with an Object Repository"
author: "Lukasz A. Bartnik"
date: "`r Sys.Date()`"
output: rmarkdown::pdf_document
vignette: >
  %\VignetteIndexEntry{Supporting Data Processing with an Object Repository}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<!--
  To jest whitepaper, wiec wszystko wylozone musi byc prost i lopatologiczie.
  Zaczynamy od "reproducibility": "na zewnątrz", jako możliwość udowodnienia
  poprawności prezentowanych wyników oraz "do wewnątrz", jako możliwość
  odtworzenia stanu pracy sprzed jakieś czasu albo potwierdzenia, że kontynuuje
  się pracę od właściwego miejsca.
  W tym drugim przypadku chodzi o zarządzanie wersjonowaniem kodu i danych
  w ramach iteracyjnie rozwijanego projektu danych.

  1. Potrzeba reproducibility i jej dwa rodzaje.

  2. Repozytorium, które zapisuje zmiany w R session ale potrafi też śledzić
     pochodzenie "wg danych", czyli które obiekty i kod posłużyły do utowrzenia
     danego obiektu.
  
  3. Przykład: kilka poleceń, które odpowiadają jakiejś prostej analizie + dwa
     widoki danych, "wg sesji" (temporalny) i "wg danych" (czyli wynikania w
     ramach wydawanych poleceń R). Różnica musi być interesująca.
  
  4. Teraz tutaj może informacja o tym, że jest "local cache" i "permanent store"
     i przykład, jak się przenosi dane pomiędzy nimi. Można tutaj wrócić do przykładu
     z poprzedniego punktu (skopiować tylko jedną ścieżkę, a drugą określić jako
     mało interesującą) albo wprowadzić kolejny przykład, tym razem prezentujący
     iteracyjne zmiany w skrypcie R i jak generują one serię obiektów, z których
     dopiero ostatni jest interesujący.
  
  5. Przykłady "biznesowe". Jak repozytorium wpisuje się w projekty danych:

     - reproducibility
     - wersjonowanie i bookkeeping w trakcie projektu
     - raportowanie z RMarkdown
-->

# Abstract

In the recent years the notion of _reproducible science_ has gained a lot of
well-deserved attention. Its most important tenant is reporting results
of research projects in ways that enable independent verification. Of
course, scientists have always strived to document their research and
receive independent confirmation but the increase of data set sizes and
the complexity of experiments conducted on those data sets have made
reproducibility and confirmation more difficult, hence the counter
measure of _reproducible science_. In the world of the R Project
_reproducible science_ has taken many forms: from literate programming
with _RMarkdown_ and _knitr_, to a plethora of interactive widgets based
on _Shiny_, to object caches like _archivist_. This white paper proposes
a new addition to the toolset of _reproducible science_ as implemented
in _R_, an interactive history browser built on top of a repository of
R objects. It quietly keeps track of all changes made to a R session and
upon request provides means to browse the history of those changes:
changes to data objects (data and models), function objects (code) and
plots. Through this, verifying the exact origin, from the very first
data load instruction, through its itermediate stages related to the ETL
process, to the final model and prediction results becomes straightforward
and reduces the work overhead. Information stored in the object repository
can be browsed, loaded back to R session, or exported as binary and text
files, including an automatically generated _RMarkdown_ report.


# Introduction

This paper focuses on a subarea of scientific research centered on
exploring, understanding and modeling data. In that context, an
intuitive notion of a _data project_ is any data-related research
limited in time and scope, where code is shared and data is iteratively
transformed. It is typically concluded in a form of scientific paper or
a report consumed by a decision-maker.

In the recent years we have observed a growth in both the size of data
sets undergoing analysis and the complexity of said analyses. This in
turn resulted in broad push for reproducibility, that is, documenting
and publishing results in a manner that facilitates verification by
peers and makes the research easier to build on.

Within the R community, the need for reproducible research is well
understood and accepted which is clearly demonstrated by a variety
of related tools and packages[^reproducible-research-cran-view]. Most of
these packages are aimed at the _external_ aspect of reproducibility,
that is, publishing the results in a form that focuses on enabling
_others_ to repeat the work. There is, however, also the _internal_
aspect of reproducibility: reducing the overhead of documenting and
organizing a data project without increasing the risk of errors.

The object repository and interactive browser presented in this paper
are aimed at exactly this: attaining reproducibility with less overhead
and simplifying the task of tracking the progress and organizing
artifacts (data, code and plots) of a data project. Thus, not only code
but also data and plots can be stored and versioned automatically[^versioning].


[^reproducible-research-cran-view]: xxx

[^versioning]: Code versioning is a known and well-established concept
in computer science. Versioning data and other reserach artifacts closes
a certain gap in the conceptual approach to data research.


# Repository and Browser

The basic R execution model is twofold: either interactive, executed
through _R console_ (and various wrappers built around it, for example
_R Studio_) or batch-based, accessible via _R CMD BATCH_ and _Rscript_.
In the batch mode, R expects a file with a sequence of commands written
in the _R programming language_. This programming language, however,
is designed specifically for interactive use, and it is the interactive
mode where R shows the full extent of its capabilities. The two central
elements of the interactive mode are the _command line_ which accepts R
expressions and and the _global environment_ which stores the results of
evaluating said expressions. Global environment is maintained throughout
the life or _R session_ and can be stored in the filesystem upon exiting
R, or otherwise is lost.

The object repository described in this paper tracks changes made to R's
global environment within a number of R sessions. Thus, it is capable of
tracking research progress made during the whole lifecycle of a project.
The history of work done in R is stored as a series of _commits_, where
each commit represents the state of R session after the execution of a
single command. Each commit contains:

  * a list of pointers to objects
  * a pointer to the parent commit
  * a pointer to a plot, if one was made instead of changing the
    contents of global environment
  * the last R expression executed in the command line
  * the time of creation

Objects found in the global environment are stored separately from the
commit itself, and are pointed to by their unique identifier, a hash key
computed from their contents. Thus, even if a given object appears in
more than one commit, it is still stored only once. Moreover, that
multiple appearance can be easily spotted and exposed to the user,
should that bear significance in the context of the research. Each
object stored in the repository contains:

  * the actual contents of the R object
  * pointers to one or more _parent_ objects
  * the creation time
  * additional _tags_ provided by the user, for example, a text note




__An example of a number of R expressions and what is stored in the repo__


  2. Repozytorium, które zapisuje zmiany w R session ale potrafi też śledzić
     pochodzenie "wg danych", czyli które obiekty i kod posłużyły do utowrzenia
     danego obiektu.

# Data Views
  3. Przykład: kilka poleceń, które odpowiadają jakiejś prostej analizie + dwa
     widoki danych, "wg sesji" (temporalny) i "wg danych" (czyli wynikania w
     ramach wydawanych poleceń R). Różnica musi być interesująca.

# Iterative Development in a Data Project
  4. Teraz tutaj może informacja o tym, że jest "local cache" i "permanent store"
     i przykład, jak się przenosi dane pomiędzy nimi. Można tutaj wrócić do przykładu
     z poprzedniego punktu (skopiować tylko jedną ścieżkę, a drugą określić jako
     mało interesującą) albo wprowadzić kolejny przykład, tym razem prezentujący
     iteracyjne zmiany w skrypcie R i jak generują one serię obiektów, z których
     dopiero ostatni jest interesujący.

# Repository at Work
  5. Przykłady "biznesowe". Jak repozytorium wpisuje się w projekty danych:

     - reproducibility
     - wersjonowanie i bookkeeping w trakcie projektu
     - raportowanie z RMarkdown
