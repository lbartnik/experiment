"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

// Generated by CoffeeScript 2.0.3
(function () {
  var Data, Description, Position, UI, Widget, Widget2, euclidean, mapNodes;

  Array.prototype.unique = function () {
    var j, key, output, ref, results, value;
    output = {};
    for (key = j = 0, ref = this.length; 0 <= ref ? j < ref : j > ref; key = 0 <= ref ? ++j : --j) {
      output[this[key]] = this[key];
    }
    results = [];
    for (key in output) {
      value = output[key];
      results.push(value);
    }
    return results;
  };

  // Helper function to map node id's to node objects.
  // Returns d3.map of ids -> nodes
  mapNodes = function mapNodes(nodes) {
    var nodesMap;
    nodesMap = d3.map();
    nodes.forEach(function (n) {
      return nodesMap.set(n.id, n);
    });
    return nodesMap;
  };

  euclidean = function euclidean(a, b) {
    return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
  };

  // --- Utils ------------------------------------------------------------
  UI = function UI(selection) {
    var nodeR = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 25;
    var innerR = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 25;

    var canvas, createGraphics, linksG, nodesG, outer, ui;
    outer = null;
    canvas = null;
    linksG = null;
    nodesG = null;
    ui = function ui() {};
    ui.initialize = function () {
      outer = d3.select(selection).append("div").attr("class", "widget").style("overflow", "auto").style('overflow-y', 'auto');
      canvas = outer.append("svg");
      linksG = canvas.append("g").attr("id", "links");
      return nodesG = canvas.append("g").attr("id", "nodes");
    };
    ui.setSize = function (width, height) {
      // reduce the size to make sure scrolls don't show right away
      return canvas.attr("width", width - 10).attr("height", height - 10).attr("viewBox", "0 0 " + width + " " + height);
    };
    ui.setData = function (data) {
      return createGraphics(data);
    };
    // create all graphical elements on the canvas
    createGraphics = function createGraphics(data) {
      var enter, link, node;
      node = nodesG.selectAll("svg.variable").data(data.steps, function (d) {
        return d.id;
      });
      enter = node.enter().append("svg").attr("class", function (d) {
        return "variable " + d.type;
      }).attr("id", function (d) {
        return d.id;
      }).attr("viewBox", "0 0 " + 2 * innerR + " " + 2 * innerR).attr("width", 2 * nodeR).attr("height", 2 * nodeR);
      enter.each(function (d) {
        var element;
        element = d3.select(this);
        if (d.type === 'object') {
          element.append("rect").attr("width", 2 * innerR).attr("height", 2 * innerR).attr("rx", innerR / 2).attr("ry", innerR / 2);
          element.append("text").attr("class", "label").attr("text-anchor", "middle").attr("alignment-baseline", "middle").attr("y", '50%').attr("x", '50%').text(function (d) {
            return d.name;
          });
          return element.append("rect").attr("class", "face").attr("width", 2 * innerR).attr("height", 2 * innerR);
        } else {
          if (d.contents) {
            return element.append("image").attr("width", 2 * innerR).attr("height", 2 * innerR).attr("xlink:href", $("#plot" + d.id).attr("href"));
          } else {
            return element.append("rect").attr('width', 2 * innerR).attr('height', 2 * innerR).style("fill", "grey");
          }
        }
      });
      node.exit().remove();
      link = linksG.selectAll("line.link").data(data.links, function (d) {
        return d.source.id + "_" + d.target.id;
      });
      link.enter().append("line").attr("class", "link").attr("stroke", "#ddd");
      return link.exit().remove();
    };
    // --- createGraphics
    ui.updatePositions = function () {
      var link;
      nodesG.selectAll("svg.variable").attr("x", function (d) {
        return d.x - d.scale * nodeR;
      }).attr("y", function (d) {
        return d.y - d.scale * nodeR;
      }).attr("width", function (d) {
        return d.scale * 2 * nodeR;
      }).attr("height", function (d) {
        return d.scale * 2 * nodeR;
      });
      return link = linksG.selectAll("line.link").attr("x1", function (d) {
        return d.source.x;
      }).attr("y1", function (d) {
        return d.source.y;
      }).attr("x2", function (d) {
        return d.target.x;
      }).attr("y2", function (d) {
        return d.target.y;
      });
    };
    ui.mousePosition = function () {
      var x, y;

      var _d3$mouse = d3.mouse(canvas.node());

      var _d3$mouse2 = _slicedToArray(_d3$mouse, 2);

      x = _d3$mouse2[0];
      y = _d3$mouse2[1];

      return {
        x: x,
        y: y
      };
    };
    ui.nodesNear = function (point, distance) {
      var intList, n, parents, rc;
      rc = canvas.node().createSVGRect();
      rc.x = point.x - distance;
      rc.y = point.y - distance;
      rc.width = 2 * distance;
      rc.height = 2 * distance;
      // returns SVG node elements inside the parent svg
      intList = canvas.node().getIntersectionList(rc, nodesG.node());
      parents = function () {
        var j, len, results;
        results = [];
        for (j = 0, len = intList.length; j < len; j++) {
          n = intList[j];
          results.push(n.parentNode);
        }
        return results;
      }().unique();
      return parents.filter(function (n) {
        return euclidean(d3.select(n).datum(), point) <= distance;
      });
    };
    // --- events ---
    ui.on = function (event, callback) {
      // canvas-level events
      if (event === 'canvas:mousemove' || event === 'canvas:mouseout') {
        canvas.on(event.substring(7), callback);
      }
      // node-level events
      if (event === 'node:mouseover' || event === 'node:mouseout') {
        return nodesG.selectAll(".face,image").on(event.substring(5), callback);
      }
    };
    ui.initialize();
    return ui;
  };

  // --- UI ---------------------------------------------------------------
  Data = function Data(data) {
    var setupData;
    data.resetScale = function () {
      return data.steps.forEach(function (s) {
        return s.scale = 1;
      });
    };
    // pre-process the input data
    setupData = function setupData() {
      var stepsMap;
      data.resetScale();
      // pre-process nodes
      data.steps.forEach(function (s) {
        if (s.expr.constructor === Array) {
          return s.expr = s.expr.join('\n');
        }
      });
      // replace target/source references in links with actual objects
      stepsMap = mapNodes(data.steps);
      return data.links.forEach(function (l) {
        l.source = stepsMap.get(l.source);
        return l.target = stepsMap.get(l.target);
      });
    };
    // initialize the object
    setupData();
    return data;
  };

  // --- Data -------------------------------------------------------------
  Position = function Position(width, height, margin) {
    var position, stratified, treed;
    width = width - margin * 2;
    height = height - margin * 2;
    position = function position() {};
    stratified = function stratified(data) {
      var parentsMap, stratify;
      parentsMap = d3.map();
      data.links.forEach(function (l) {
        return parentsMap.set(l.target.id, l.source.id);
      });
      stratify = d3.stratify().id(function (d) {
        return d.id;
      }).parentId(function (d) {
        return parentsMap.get(d.id);
      });
      return stratify(data.steps);
    };
    treed = function treed(data) {
      var tree;
      data.sort();
      tree = d3.tree().size([width, height]);
      return tree(data);
    };
    position.calculate = function (data) {
      var dx, dy, max_x, max_y, min_x, min_y, nodesMap, s, t, x, y;
      // use d3 to calculate positions for a tree
      s = stratified(data);
      t = treed(s);
      // centralize the tree
      x = t.descendants().map(function (n) {
        return n.x;
      });
      y = t.descendants().map(function (n) {
        return n.y;
      });
      min_x = x.reduce(function (a, b) {
        return Math.min(a, b);
      });
      max_x = x.reduce(function (a, b) {
        return Math.max(a, b);
      });
      min_y = y.reduce(function (a, b) {
        return Math.min(a, b);
      });
      max_y = y.reduce(function (a, b) {
        return Math.max(a, b);
      });
      dx = width - max_x - min_x + margin;
      dy = height - max_y - min_y + margin;
      // update original nodes' positions
      nodesMap = mapNodes(data.steps);
      return t.each(function (n) {
        s = nodesMap.get(n.id);
        s.x = n.x + dx;
        return s.y = n.y + dy;
      });
    };
    // --- calculate ---

    // return an instance of the Position object
    return position;
  };

  // --- Position ---------------------------------------------------------
  Description = function Description(element, step, outer) {
    var description, template;
    template = "<div class=\"tooltip\">\n    <div class=\"inner\">\n        <span class=\"name\">{{name}}</span>\n        <span class=\"description\">{{description}}</span>\n        <pre><code class=\"R\">{{code}}</code></pre>\n    </div>\n</div>";
    description = function description() {};
    description.show = function () {
      var bcr, inner, pos, ref, tooltip;
      tooltip = $("<div>").addClass("tooltip").attr("id", "tooltip_" + step.id);
      if (step.type === "object") {
        inner = $("<div>").addClass("inner").appendTo(tooltip);
        $("<span>").addClass("name").appendTo(inner).text(step.name);
        $("<span>").addClass("description").appendTo(inner).text(step.desc);
        $("<pre>").appendTo(inner).append($("<code>").addClass("R").text(step.expr));
        inner.find("pre code").each(function (i, block) {
          return hljs.highlightBlock(block);
        });
      } else {
        $("<img>", {
          src: 'links/' + step.contents,
          width: 300
        }).appendTo(tooltip);
      }
      pos = $(outer).parent().position();
      bcr = element.getBoundingClientRect();
      tooltip.css({
        left: bcr.left + bcr.width,
        top: bcr.top + bcr.height
      });
      if ((ref = element.tooltip) != null) {
        ref.remove();
      }
      return element.tooltip = tooltip.appendTo(outer).css({
        visibility: 'visible'
      }).fadeTo('fast', 1);
    };
    description.hide = function () {
      var ref;
      return (ref = element.tooltip) != null ? ref.fadeTo('fast', 0, function () {
        var ref1;
        return (ref1 = element.tooltip) != null ? ref1.remove() : void 0;
      }) : void 0;
    };
    return description;
  };

  // --- Widget -----------------------------------------------------------
  Widget = function Widget(selection) {
    var data, hideDialog, lenseR, moveLenses, nodeR, pos, resetScale, setEvents, showDialog, ui, widget;
    nodeR = 15;
    lenseR = 50;
    ui = UI(selection, nodeR);
    pos = Position(500, 500, nodeR);
    data = null;
    widget = function widget() {};
    widget.setData = function (input) {
      data = Data(input);
      ui.setData(data);
      pos.calculate(data);
      ui.updatePositions();
      return setEvents();
    };
    widget.setSize = function (width, height) {
      ui.setSize(width, height);
      return pos = Position(width, height, nodeR);
    };
    setEvents = function setEvents() {
      ui.on('canvas:mousemove', moveLenses);
      ui.on('canvas:mouseout', resetScale);
      ui.on('node:mouseover', showDialog);
      return ui.on('node:mouseout', hideDialog);
    };
    moveLenses = function moveLenses(d) {
      var mouse, nodes;
      data.resetScale();
      mouse = ui.mousePosition();
      nodes = ui.nodesNear(mouse, lenseR);
      nodes.forEach(function (n) {
        var datum, scale;
        datum = d3.select(n).datum();
        scale = euclidean(mouse, datum) / lenseR;
        return datum.scale = 1 + lenseR / nodeR * Math.sqrt(1 - scale);
      });
      return ui.updatePositions();
    };
    resetScale = function resetScale(d) {
      data.resetScale();
      return ui.updatePositions();
    };
    showDialog = function showDialog(d) {
      this.description = Description(this, d, selection);
      return this.description.show();
    };
    hideDialog = function hideDialog(d) {
      return this.description.hide();
    };
    return widget;
  };

  Widget2 = function Widget2(selection) {
    var addPlot, createVisuals, data, enableEvents, filterData, hidePlot, hideVariable, lenses, lenses_r, linksG, moveLenses, nodesG, placeVisuals, refreshVisuals, setupData, showPlot, showVariable, template, thumbnail, timeout, toClipboard, updatePositions, vis, widget, zoomFrame, zoomed;
    lenses_r = 50;
    timeout = 150;
    thumbnail = 25;
    zoomed = 250;
    data = null;
    vis = d3.select(selection).attr("class", "widget").style("overflow", "auto").style('overflow-y', 'auto').append("svg");
    lenses = vis.append("circle");
    linksG = vis.append("g").attr("id", "links");
    nodesG = vis.append("g").attr("id", "nodes");
    template = "<div class=\"tooltip\">\n    <div class=\"inner\">\n        <span class=\"name\">{{name}}</span>\n        <span class=\"description\">{{description}}</span>\n        <pre><code class=\"R\">{{code}}</code></pre>\n    </div>\n</div>";
    widget = function widget() {};
    widget.setSize = function (width, height) {
      vis.attr("width", width * .95).attr("height", height * .95).attr("viewBox", "0 0 " + width + " " + height);
      if (data) {
        return refreshVisuals();
      }
    };
    widget.setData = function (Data) {
      data = setupData(Data);
      return refreshVisuals();
    };
    refreshVisuals = function refreshVisuals() {
      var filtered;
      filtered = filterData(data);
      createVisuals(filtered);
      placeVisuals(filtered);
      return enableEvents();
    };
    setupData = function setupData(data) {
      var stepsMap;
      // replace target/source references in links with actual objects
      stepsMap = mapNodes(data.steps);
      data.links.forEach(function (l) {
        l.source = stepsMap.get(l.source);
        return l.target = stepsMap.get(l.target);
      });
      return data;
    };
    // Helper function to map node id's to node objects.
    // Returns d3.map of ids -> nodes
    mapNodes = function mapNodes(nodes) {
      var nodesMap;
      nodesMap = d3.map();
      nodes.forEach(function (n) {
        return nodesMap.set(n.id, n);
      });
      return nodesMap;
    };
    filterData = function filterData(data) {
      return data;
    };
    createVisuals = function createVisuals(data) {
      var enter, j, len, link, node, nodeSize, ref, step, steps;
      // this sizes each node
      nodeSize = function nodeSize(selection) {
        return selection.attr("width", 2 * thumbnail).attr("height", thumbnail).attr("rx", thumbnail / 3).attr("ry", thumbnail / 3);
      };
      // the lense circle goes to the bottom
      lenses.attr("class", "lenses").attr("r", 50);
      d3.select(window).on("mousemove", moveLenses);
      // add regular steps
      steps = function () {
        var j, len, ref, results;
        ref = data.steps;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          step = ref[j];
          if (step.type === 'object') {
            results.push(step);
          }
        }
        return results;
      }();
      node = nodesG.selectAll("g.variable").data(steps, function (d) {
        return d.id;
      });
      enter = node.enter().append("svg").attr("class", "variable").attr("viewBox", "-1 -2 52 29").attr("width", "50").attr("height", "25").attr("id", function (d) {
        return d.id;
      });
      nodeSize(enter.append("rect"));
      enter.append("text").attr("class", "label").attr("text-anchor", "middle").attr("alignment-baseline", "middle").attr("y", '50%').attr("x", '50%').text(function (d) {
        return d.name;
      });
      nodeSize(enter.append("rect")).attr("class", "face");
      node.exit().remove();
      ref = data.steps;
      for (j = 0, len = ref.length; j < len; j++) {
        step = ref[j];
        if (step.type === 'plot') {

          // add plots
          addPlot(step);
        }
      }
      link = linksG.selectAll("line.link").data(data.links, function (d) {
        return d.source.id + "_" + d.target.id;
      });
      link.enter().append("line").attr("class", "link").attr("stroke", "#ddd");
      return link.exit().remove();
    };
    moveLenses = function moveLenses(e) {
      var il, m, ps, rc, x;
      m = d3.mouse(vis.node());
      lenses.attr("cx", m[0]).attr("cy", m[1]);
      data.steps.forEach(function (s) {
        return s.scale = 1;
      });
      rc = vis.node().createSVGRect();
      rc.x = m[0] - lenses_r;
      rc.y = m[1] - lenses_r;
      rc.width = m[0] + lenses_r;
      rc.height = m[1] + lenses_r;
      il = vis.node().getIntersectionList(rc, nodesG.node());
      ps = function () {
        var j, len, results;
        results = [];
        for (j = 0, len = il.length; j < len; j++) {
          x = il[j];
          results.push(x.parentNode);
        }
        return results;
      }().unique();
      ps.forEach(function (p) {
        var datum, px, py, scale;
        datum = d3.select(p).datum();
        px = datum.x;
        py = datum.y;
        scale = Math.min(50, Math.sqrt(Math.pow(px - m[0], 2) + Math.pow(py - m[1], 2)));
        return datum.scale = 2 - scale / 50;
      });
      return nodesG.selectAll("svg").attr("width", function (d) {
        return d.scale * 2 * thumbnail;
      }).attr("height", function (d) {
        return d.scale * thumbnail;
      });
    };
    addPlot = function addPlot(step) {
      var bb, plot;
      plot = vis.append("svg");
      if (step.contents) {
        plot.append("image").attr("width", 50).attr("height", 50).attr("xlink:href", $("#plot" + step.id).attr("href"));
      } else {
        plot.append("rect").attr('width', 150).attr('height', 150).style("fill", "grey");
      }
      plot = plot.node();
      // extract and remember the original size
      bb = plot.getBBox();
      step.width = bb.width - bb.x;
      step.height = bb.height - bb.y;
      // add the visual
      return d3.select(plot).data([step]).attr("id", "plot" + step.id).attr("class", "plot").attr("viewBox", bb.x + " " + bb.y + " " + bb.width + " " + bb.height).attr("width", thumbnail).attr("height", thumbnail).append("rect").attr("class", "face").attr('width', '100%').attr('height', '100%');
    };
    placeVisuals = function placeVisuals(data) {
      var height, min_x, min_y, nodesMap, parentsMap, root, stratify, tree, width;
      parentsMap = d3.map();
      data.links.forEach(function (l) {
        return parentsMap.set(l.target.id, l.source.id);
      });
      stratify = d3.stratify().id(function (d) {
        return d.id;
      }).parentId(function (d) {
        return parentsMap.get(d.id);
      });
      root = stratify(data.steps);
      width = vis.attr("width");
      height = vis.attr("height");
      // give the tree layout a somewhat smaller area (w/h-thumbnail*4)    
      root.sort();
      tree = d3.tree().size([width - thumbnail * 4, height - thumbnail * 4]);
      root = tree(root);
      min_x = root.descendants().map(function (n) {
        return n.x;
      }).reduce(function (a, b) {
        return Math.min(a, b);
      });
      min_y = root.descendants().map(function (n) {
        return n.y;
      }).reduce(function (a, b) {
        return Math.min(a, b);
      });
      // mode all nodes, take the marings into account (+2*thumbnail)
      nodesMap = mapNodes(data.steps);
      root.each(function (n) {
        var s;
        s = nodesMap.get(n.id);
        s.x = n.x + thumbnail - min_x + thumbnail * 2;
        return s.y = n.y + thumbnail / 1.75 - min_y + thumbnail * 2;
      });
      updatePositions();
      //bb = vis.node().getBBox()
      //x      = bb.x - thumbnail
      //y      = bb.y - thumbnail
      //width  = Math.max(bb.width + 2*thumbnail, vis.attr("width"))
      //height = Math.max(bb.height  + 2*thumbnail, vis.attr("height"))
      return vis.attr("width", width).attr("height", height).attr("viewBox", "0 0 " + width + " " + height);
    };
    updatePositions = function updatePositions() {
      var link;
      nodesG.selectAll("svg.variable").attr("x", function (d) {
        return d.x - thumbnail;
      }).attr("y", function (d) {
        return d.y - thumbnail / 2;
      });
      vis.selectAll("svg.plot").attr("x", function (d) {
        return d.x - thumbnail / 2;
      }).attr("y", function (d) {
        return d.y - thumbnail / 2;
      });
      return link = linksG.selectAll("line.link").attr("x1", function (d) {
        return d.source.x;
      }).attr("y1", function (d) {
        return d.source.y;
      }).attr("x2", function (d) {
        return d.target.x;
      }).attr("y2", function (d) {
        return d.target.y;
      });
    };
    enableEvents = function enableEvents() {
      vis.selectAll(".plot > rect.face").on("mouseover", showPlot).on("mouseout", hidePlot).on("click", toClipboard);
      return vis.selectAll(".variable > rect.face").on("mouseover", showVariable).on("mouseout", hideVariable).on("click", toClipboard);
    };
    // transition outside
    showPlot = function showPlot(step) {
      var ref, self;
      step.dx = Math.max(0, step.x + zoomed - vis.attr("width"));
      step.dy = Math.max(0, step.y + zoomed / step.width * step.height - vis.attr("height"));
      if ((ref = this.animation) != null) {
        ref.stop();
      }
      return this.animation = self = d3.timer(function (elapsed) {
        if (elapsed >= timeout) {
          self.stop();
        }
        return zoomFrame(step, Math.min(elapsed / timeout, 1));
      });
    };
    // transition inside
    hidePlot = function hidePlot(step) {
      var ref, self;
      if ((ref = this.animation) != null) {
        ref.stop();
      }
      return this.animation = self = d3.timer(function (elapsed) {
        if (elapsed >= timeout) {
          self.stop();
        }
        return zoomFrame(step, Math.max(1 - elapsed / timeout, 0));
      });
    };
    zoomFrame = function zoomFrame(step, alpha) {
      var zoom;
      zoom = Math.max(zoomed * alpha, thumbnail);
      return vis.select("#plot" + step.id).attr("width", zoom).attr("height", zoom / step.width * step.height).attr("x", step.x - thumbnail / 2 - step.dx * alpha).attr("y", step.y - thumbnail / 2 - step.dy * alpha);
    };
    showVariable = function showVariable(step) {
      var bcr, code, pos, ref, rendered, tooltip;
      Mustache.parse(template);
      code = step.expr.constructor === Array ? step.expr.join('\n') : step.expr;
      rendered = Mustache.render(template, {
        name: step.name,
        code: code,
        description: step.desc
      });
      tooltip = $(rendered);
      pos = $(selection).parent().position();
      bcr = this.getBoundingClientRect();
      tooltip.attr("id", "tooltip_" + step.id).css({
        left: bcr.left + bcr.width,
        top: bcr.top + bcr.height
      }).find("pre code").each(function (i, block) {
        return hljs.highlightBlock(block);
      });
      tooltip.find(".inner").css({
        zoom: .1
      });
      if ((ref = this.tooltip) != null) {
        ref.remove();
      }
      this.tooltip = tooltip.appendTo(selection);
      return tooltip.css({
        visibility: 'visible'
      }).find(".inner").animate({
        zoom: 1
      }, 'fast');
    };
    hideVariable = function hideVariable(step) {
      var ref, thisNode;
      thisNode = this;
      return (ref = this.tooltip) != null ? ref.find('.inner').animate({
        zoom: 0
      }, 'fast', 'swing', function () {
        var ref1;
        return (ref1 = thisNode.tooltip) != null ? ref1.remove() : void 0;
      }) : void 0;
    };
    toClipboard = function toClipboard(step) {
      var input;
      input = $("<input>").appendTo(selection).val("restore('" + step.id + "')").select();
      document.execCommand("copy");
      input.remove();
      return $.notify("ID copied to clipboard", {
        autoHideDelay: 1000,
        className: 'info',
        style: 'simplenotification'
      });
    };
    widget.setSize($(selection).width(), $(selection).height());
    return widget;
  };

  // add style to notifyjs, just once
  $.notify.addStyle('simplenotification', {
    html: "<div><span data-notify-text/></div>"
  });

  // export the Widget
  window.Widget = Widget;
}).call(undefined);