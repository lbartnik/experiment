'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Generated by CoffeeScript 2.0.3
(function () {
  var registerTests,
      _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  registerTests = function registerTests(sampleData) {
    var assert, suite, test;
    assert = chai.assert;
    suite = Mocha.suite;
    test = Mocha.test;
    // check that basic CoffeeScript idioms work as expected
    suite('Idioms', function () {
      return test('clone array and elements', function () {
        var x, y;
        x = [{
          x: 1
        }, {
          x: 2
        }];
        y = x.map(function (e) {
          return _extends({}, e);
        });
        y[0].x = 3;
        return assert.equal(x[0].x, 1);
      });
    });
    suite('Data', function () {
      var unique;
      // helpers
      unique = function unique(a) {
        var i, key, output, ref, ref1, results, value;
        output = {};
        for (key = i = 0, ref = a.length; 0 <= ref ? i < ref : i > ref; key = 0 <= ref ? ++i : --i) {
          output[(ref1 = a[key].id) != null ? ref1 : a[key]] = a[key];
        }
        results = [];
        for (key in output) {
          value = output[key];
          results.push(value);
        }
        return results;
      };
      // test cases
      return suite('Data construction', function () {
        // sample data
        setup(function () {
          this.raw = sampleData;
          return this.data = new Data(JSON.parse(JSON.stringify(sampleData)));
        });
        test('data sanity', function () {
          var step;
          assert('links' in this.raw);
          assert('steps' in this.raw);
          assert.lengthOf(this.raw.steps, 4);
          assert.sameMembers(unique(function () {
            var i, len, ref, results;
            ref = this.raw.steps;
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
              step = ref[i];
              results.push(step.id !== void 0);
            }
            return results;
          }.call(this)), [true]);
          return assert.sameMembers(unique(function () {
            var i, len, ref, results;
            ref = this.raw.steps;
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
              step = ref[i];
              results.push(_typeof(step.expr));
            }
            return results;
          }.call(this)), ['object', 'string']);
        });
        test('concat expression', function () {
          var step;
          return assert.sameMembers(unique(function () {
            var i, len, ref, results;
            ref = this.data.steps();
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
              step = ref[i];
              results.push(_typeof(step.expr));
            }
            return results;
          }.call(this)), ['string']);
        });
        test('replace id with object', function () {
          var steps;
          steps = this.data.steps();
          return this.data.links().forEach(function (link) {
            assert.hasAllKeys(link, ['target', 'source']);
            return assert.includeDeepMembers(steps, [link.target]);
          });
        });
        return test('sequence', function () {});
      });
    });
    return null;
  };

  window.registerTests = registerTests;
}).call(undefined);